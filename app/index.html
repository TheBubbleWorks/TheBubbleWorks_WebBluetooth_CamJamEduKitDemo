<!doctype html>
<html>
<head>
    <title>CamJam EduKit Robot</title>
    <meta name="description" content="Control a CAmJam EduKit Robot Web Bluetooth.">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <!-- Polyfill Web Components support for older browsers -->
    <script src="bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>

    <!-- Because this project uses vulcanize this should be your only html import
     in this file. All other imports should go in elements.html -->
    <link rel="import" href="elements/elements.html">
    <script src="scripts/app.js"></script>

    <script>
        function uartRxNotification(event) {
            let value = event.target.value;
            log("RX: + " + value);
        }
    </script>

    <script>
        // see: http://blog.getsentry.com/2016/01/04/client-javascript-reporting-window-onerror.html
        function wrapErrors(fn) {
            // don't wrap function more than once
            if (!fn.__wrapped__) {
                fn.__wrapped__ = function () {
                    try {
                        return fn.apply(this, arguments);
                    } catch (e) {
                        log(e); // report the error
                        throw e; // re-throw the error
                    }
                };
            }

            return fn.__wrapped__;
        }

        function log(line) {
            console.log(line);
            var textarea = document.getElementById('consoleTextArea');
            previous_text = textarea.innerHTML;
            textarea.innerHTML = previous_text + line + "\n";
            textarea.scrollTop = textarea.scrollHeight;

        }
        window.onerror = function (msg, url, lineNo, columnNo, error) {
            log('Error: ' + msg + ' Script: ' + url + ' Line: ' + lineNumber);
            return false;
        }
    </script>


</head>

<body>
<body>
<div>
    <button id="connectButton" onclick="setupBluetooth()">Connect</button>
</div>
<br/>
<div>
    <button id="onButton" onclick="ledOnPressed()">LED On</button>
</div>
<br/>
<div>
    <button id="offButton" onclick="ledOffPressed()">LED Off</button>
</div>
<br/>

<script>
    // These 128-Bit ID's correspond to the Nordic Semi-conductor 'UART' BLE service which is used by Adafruit and others.
    var UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    var UART_CHAR_RX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
    var UART_CHAR_TX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

    var connected = false;
    var gattServer = null;
    var uartService = null;
    var writeCharacteristic = null;
    var readCharacteristic = null;

    function handleError(error) {
        log("ERROR:" + error);
    }

    function setupBluetooth() {
        if (navigator.bluetooth == undefined) {
            handleError('ERROR: Web Bluetooth support not found, please see: https://goo.gl/5p4zNM');
            return;
        }

        if (gattServer != null && gattServer.connected) {
            //disconnect();
        } else {
            log('Connecting...');
            if (readCharacteristic == null) {
                navigator.bluetooth.requestDevice({
                            filters: [{
                                services: [UART_SERVICE_UUID]
                            }]
                        })
                        .then(function (device) {
                            log('> DeviceNAme=' + device.name);
                            log('Connecting to GATT Server...');
                            return device.connectGATT(); // This is deprectated, but still necessary in some 'older' browser versions.
                        }).then(function (server) {
                    log('> Found GATT server');
                    gattServer = server;
                    // Get UART service
                    return gattServer.getPrimaryService(UART_SERVICE_UUID);
                }).then(function (service) {
                    log('> Found event service');
                    uartService = service;
                    // Get write characteristic
                    return uartService.getCharacteristic(UART_CHAR_TX_UUID);
                }).then(function (characteristic) {
                    log('> Found write characteristic');
                    writeCharacteristic = characteristic;
                    // Get read characteristic
                    return uartService.getCharacteristic(UART_CHAR_RX_UUID);
                }).then(function (characteristic) {
                    connected = true;
                    log('> Found read characteristic');
                    readCharacteristic = characteristic;


                    deviceReady();

                    // Listen to device notifications
                    return readCharacteristic.startNotifications().then(function () {

                        readCharacteristic.addEventListener('characteristicvaluechanged', function (event) {
                            log('> characteristicvaluechanged = ' + event.target.value + ' [' + event.target.value.byteLength + ']');
                            if (event.target.value.byteLength > 0) {
                                var data = new Uint8Array(event.target.value);
                                log("Recv data: " + data);

                            }
                        });
                    });
                }).catch(handleError);
            }
        }
    }

    // These magic hex numbers below conform to the made up standard just for these demos, in a real app you would use
    // an existing (if the device/protocol exists already) or a custom JavaScript library to hide such details.
    // These correspond to whe the BLE peripheral device running as a service on the Raspberry Pi
    // see:

    function send(data) {
        log("Sending: " + data);
        return writeCharacteristic.writeValue(new Uint8Array(data));
    }

    var RPIGPIO_PIN23_DIGITAL_OUT_MESSAGE  = [0x00, 0x31, 0x01, 0x17, 0x02];
    var RPIGPIO_PIN23_DIGITAL_LOW_MESSAGE  = [0x00, 0x31, 0x02, 0x17, 0x00];
    var RPIGPIO_PIN23_DIGITAL_HIGH_MESSAGE = [0x00, 0x31, 0x02, 0x17, 0x01];

    function deviceReady() {
        //send(RPIGPIO_PIN23_DIGITAL_OUT_MESSAGE);
    }

    function ledOnPressed() {
        send(RPIGPIO_PIN23_DIGITAL_HIGH_MESSAGE);
    }

    function ledOffPressed() {
        send(RPIGPIO_PIN23_DIGITAL_LOW_MESSAGE);
    }
</script>



    <!-- In browser console output for debugging, Caveman Debugging! -->
    <h4>Debug output:</h4>
    <textarea cols="80" rows="16" id="consoleTextArea" ></textarea>

</body>
</html>
